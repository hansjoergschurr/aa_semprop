\documentclass{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage{todonotes}

\usepackage[backend=biber]{biblatex}
\usepackage{hyperref}

% Math imports
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{mathtools}

\newtheorem{definition}{Definition}

\addbibresource{ref.bib}
\KOMAoption{bibliography}{totoc}

\title{AA}
\author{Hans-JÃ¶rg Schurr}

\begin{document}
\maketitle
\tableofcontents

\section{Problem Description}
\label{problemdesc}
This report summarizes the result of project work done for the lecture
``Abstract Argumentation'' at TU~Wien by Stefan Woltran. The goal of the project
was to empirically evaluate certain properties of the extensions of a set of
argumentation frameworks.

Section~\ref{problemdesc} outlines the concept of argumentation frameworks, and
extensions. Subsequently the terms Rejected Arguments and Implicit Conflicts are
defined.

Section~\ref{tools} presents the two tool that were developed for this project.
A detailed instruction on how to compile the programs, and their command line
arguments is given.

The following section describes the empirical evaluation. First the set of
frameworks is described.  Some frameworks were generated with the help of a
benchmark generator, some of them were selected from the ICCMA'15 benchmark set.
Secondly, the Aspartix framework, which was used to find the extensions is
described. Then the results are presented.

Finally section~\ref{conclusion} concludes this report with some final remarks.

\subsection{Abstract Argumentation}

Abstract Argumentation were introduced by Dung in 1995 \cite{dung1995}. The
definitions given here follow \cite{linsbichler2015hidden}.

First and foremost a countably infinite domain $\mathfrak{A}$. An argumentation
framework is a tuple $F = (A,R)$ where $A$ is a finite subset of $\mathfrak{A}$
and $R \subseteq A\times A$.  $A$ is called the set of arguments and $R$ the
attack relation.  For a framework $F = (B, S)$ the notation $A_F$ and $R_F$ is
used to refer to $B$ and $S$. Furthermore $S \rightarrowtail_F a$ denotes that
there is an $s \in S$ such hat $(s, a) \in R_F$. $a \rightarrowtail_F S$ is
defined equally. Intuitively the elements of $A$ are arguments of some form.
One example would be natural language sentences such as $a=$``I will eat ice
cream, because the sun is shining.'', and $b=$``The foreacast predicts it will
rain in 15 minutes.''. The scond sentence would then attack the first one and
therefore $b \rightarrowtail_F a$.

An argument $a$ is said to be \emph{defended} by a set $S$, if for every $b \in
A_F$ where $b \rightarrowtail_F a$ there is a $c \in S$ such that $c
\rightarrowtail_F b$. A set $T$ is said to be \emph{defended} by $S$ if every
$a \in T$ is defended by $S$. The \emph{range} $S_F^{+}$ of a set $S$ is the
set $S \cup\{b | S \rightarrowtail_F b\}$

A \emph{semantic} is a mapping from a framework to a set $\sigma(A)$ of subsets
$S$ of $A$.  $S$ then is usually called a ($\sigma$-)extension. The semantics
used in this work are:
\begin{enumerate}
  \item Conflict-free: $S \in cf(F)$, if there is no pair $a,b \in S$, such that
      $(a,b) \in R$.
  \item Admissible: $S \in adm(F)$, if $S$ defends itself.
  \item Naive: $S \in nai(F)$ if $\nexists T\in cf(F)$ with $T \supset S$.
  \item Stable: $S \in stb(F)$, if $S_F^{+} = A_F$.
  \item Preferred: $S \in prf(F)$, if $S \in adm(F)$ and $\nexists T\in adm(F)$
      with $T \supset S$.
  \item Stage: $S \in stg(F)$, if $\nexists T\in cf(F)$ with $T_F^{+} \supset
      S_F^{+}$.
  \item Semi-stable: $S \in sem(F)$, if $S \in adm(F)$ and $\nexists T\in
      adm(F)$ with $T_F^{+} \supset S_F^{+}$.
\end{enumerate}

\subsection{Framework properties}

This project concentrated on two properties of an argumentation framework
together with a set of extensions. That means, that the concrete semantic used
is at first not considered.

An argument is rejected, if it doesn't appear in any extension:

\begin{definition}
Let $F=(A,R)$ be an argumentation framework, $\sigma$ a semantic, and $a\in A$
be an argument. $a$ is \emph{rejected} if $\nexists S\in\sigma(F): a\in S$.
\end{definition}

A framework is \emph{compact} if no argument is rejected:

\begin{definition}
Let $F=(A,R)$ be an argumentation framework, and $\sigma$ a semantic.  The
framework is \emph{compact} with respect to $\sigma$ if $\forall a\in A\exists
S\in\sigma(S):a\in S$.
\end{definition}

Secondly, a framework containing no \emph{implicit conflicts} is called
\emph{analytic}.  \todo{Wird im finalen paper auch der Begriff anlaytic
verwendet?} More formally:

\begin{definition}
  Let $F=(A,R)$ be an argumentation framework, $\sigma$ be an arbitrary semantic
  and $a, b\in A$. If $\nexists S \in \sigma(F): {a,b} \subseteq S$ then $a$ and
  $b$ are in \emph{conflict}. If $(a, b) \in R$ or $(b, a)\in R$, then the
  conflict is \emph{explicit}, otherwise the conflict is \emph{implicit}.
\end{definition}

In the previous definition $a = b$ is possible. If this definition is applied to
the set of all extensions with respect to a framework and a fixed semantic.

\begin{definition}
Given an argumentation framework $F=(A,R)$ and a semantic $\sigma$, $F$ is
called \emph{analytic} if all conflicts of $F$ for $\sigma$ are explicit.
\end{definition}

Since conflicts involving an argument which is rejected are always implicit the
(number of) conflicts which do not involve a rejected argument.

\subsection{Empirical evaluation}
\todo[inline]{write description of the evaluation}

\section{The Tools}
\label{tools}
In this section the tools developed in this project word are described. The
first section gives detailed introduction how to compile them. Since the tools
are developed in the Haskell programing language, a build tool for Haskell is
used.

Then the subsequent chapter documents the \texttt{analyze} tool. This tool is
used to analyze a given set of extensions together with a framework. It outputs
a list of properties and offers a number of input formats.

\texttt{statistics} is the second tool described. Given a set of input
frameworks it automatically calls a program to compute the extensions and
subsequently uses \texttt{analyze} to compute the properties of the extensions.

\subsection{Building the tools}

Both tools are written in Haskell. While there are multiple ways to build the
tools, using \emph{Stack} is strongly suggested and documented here.

To install Stack follow the instructions on the Stack homepage
\url{https://haskellstack.org}. Then open a terminal and navigate to either
\texttt{analyze/} or \texttt{statistics/}. Then run then following command,
where \texttt{\{tool\}} is either \texttt{analyze} or \texttt{statistics}:

\begin{verbatim}
> stack setup
> stack build
> stack exec {tool}
\end{verbatim}

The \texttt{stack build} command outputs the path the resulting binary
is placed in. Calling \texttt{stack install} will copy the binary
to \texttt{\~{}/.local/bin} on Linux.

\subsection{Analyze}

The \texttt{analyze} tool uses an argumentation framework and precomputed
extensions and returns a list of properties. Executing \texttt{analyze}
without any command line arguments results in a short description of
its arguments.

\begin{verbatim}
Usage: analyze [-t] [-c] [-n] -f FILE -e FILE

  -t         The framework is in Trivial Graph Format,
    instead of Aspartix Format.
  -c         The Extensions are in ICCMA competiton format,
    instead of an output log of clasp.
  -n         Output the number of elements instead of lists
    e.g. for implicit conflicts.
  -f FILE    FILE containing the framework.
  -e FILE    FILE containing the extensions.
\end{verbatim}

Except \texttt{-f} and \texttt{-e} all arguments are optional.  The \texttt{-t}
and \texttt{-c} options control the input format. \texttt{-t} defaults to the
Aspartix format, which describes the framework using ASP syntax\footnote{For
    more information on this and the other input formats see:
\url{http://argumentationcompetition.org/2015/iccma15notes_v3.pdf}.}.
Alternatively the Trivial Graph Format can be used. The \texttt{-c} option
defaults to ``output log of clasp''. This means, that the input format is
expected to be the result of running \texttt{clasp}\footnote{See:
\url{https://www.cs.uni-potsdam.de/clasp/}} on the input framework. The intended
purpose of this option is to compute the extensions by using the
Aspartix\footnote{See:
\url{http://www.dbai.tuwien.ac.at/research/project/argumentation/systempage/}}
framework of ASP programs. Alternatively the format used in the ICCMA'15
competition can be used. The default options are better tested then the
alternative options.

Running \texttt{analyze} on an input framework $F=(A,R)$ together with a set of
extensions $\sigma(F)$ results in a list of properties:
\begin{itemize}
  \item Arguments: The number of arguments ($|A|$).
  \item Extensions:	The number of extensions ($|\sigma(F)|$)
  \item Downwards Closed:	\todo{describe}
  \item Tight: \todo{describe}
  \item Conflict Sensitive: \todo{describe}
  \item In Signatures Of: \todo{describe}
  \item Rejected Arguments: \todo{describe}
  \item Implicit Conflicts: \todo{describe}
  \item Implicit Conflicts not Rejected: \todo{describe}
\end{itemize}

\subsection{Statistics}
\todo[inline]{write desc. and manual of statistics}

\section{Evaluation}
\label{evaluation}
\todo[inline]{write short desc of evaluation}
\subsection{Generating the benchmarks}
\todo[inline]{Do this!}
\subsection{Finding Extensions using Aspartix}

\section{Conclusion}
\label{conclusion}
\todo[inline]{write}

\printbibliography
\end{document}
