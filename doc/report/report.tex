\documentclass[parskip=half]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage{todonotes}

\usepackage[backend=biber]{biblatex}
\usepackage{hyperref}
\usepackage{enumitem}

% Math imports
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{mathtools}

\newtheorem{definition}{Definition}

\addbibresource{ref.bib}
\KOMAoption{bibliography}{totoc}

\title{Project Description}
\subtitle{For Course 184.682: Abstract Argumentation}
\author{Hans-Jörg Schurr}

\begin{document}
\maketitle
\tableofcontents

\section{Problem Description}
\label{problemdesc}
This report summarizes the result of project work done for the lecture
``Abstract Argumentation'' at TU~Wien. The course was held by Uwe Egly,
Thomas Linsbichler, and Stefan Woltran.
The goal of the project
was to empirically evaluate certain properties of the extensions of a set of
argumentation frameworks.

Section~\ref{problemdesc} outlines the concept of argumentation frameworks, and
extensions. Subsequently the terms Rejected Arguments and Implicit Conflicts are
defined.

Section~\ref{tools} presents the two tool that were developed for this project.
A detailed instruction on how to compile the programs, and their command line
arguments is given.

The subsequent section describes the empirical evaluation. First the set of
frameworks is described.  Some frameworks were generated with the help of a
benchmark generator, some were selected from the ICCMA'15 benchmark set.
Secondly, the Aspartix framework, which was used to find the extensions is
described. Then the results are presented.

Finally, section~\ref{conclusion} concludes this report with some final remarks.

\subsection{Abstract Argumentation}
\label{aadef}
Abstract Argumentation were introduced by Dung in 1995 \cite{dung1995}. The
definitions given here follows \cite{linsbichler2015hidden}.

First and foremost a countably infinite domain $\mathfrak{A}$ of arguments
is assumed.

\begin{definition}
An \emph{Argumentation Framework}
is a tuple $F = (A,R)$ where $A$ is a finite subset of $\mathfrak{A}$
and $R \subseteq A\times A$.  $A$ is called the set of arguments and $R$ the
attack relation.
\end{definition}
An Argumentation Framework is essentially a directed graph.

For a framework $F = (B, S)$ the notation $A_F$ and $R_F$ is
used to refer to $B$ and $S$. Furthermore, $S \rightarrowtail_F a$ denotes that
there is an $s \in S$ such hat $(s, a) \in R_F$. $a \rightarrowtail_F S$ is
defined equally. Intuitively, the elements of $A$ are arguments of some form.
One example would be natural language sentences such as $a=$``I will eat ice
cream, because the sun is shining.'', and $b=$``The foreacast predicts it will
rain in 15 minutes.''. The second sentence would then attack the first one and
therefore $b \rightarrowtail_F a$.
\begin{definition}
The \emph{range} $S_F^{+}$ of a set $S$ is the
set $S \cup\{b\,|\,S \rightarrowtail_F b\}$
\end{definition}

Now it can be defined what it means if an argument is said to be
\emph{defended}.
\begin{definition}
An argument $a$ is said to be \emph{defended} by a set $S$, if for every $b \in
A_F$ where $b \rightarrowtail_F a$ there is a $c \in S$ such that $c
\rightarrowtail_F b$. A set $T$ is said to be \emph{defended} by $S$ if every
$a \in T$ is defended by $S$.
\end{definition}

The second central concept of Abstract Argumentation is the concept of
a \emph{semantic}:
\begin{definition}
A \emph{semantic} is a mapping from a framework to a set $\sigma(A)$ of subsets
$S$ of $A$.  $S$ then is usually called a ($\sigma$-)extension.
\end{definition}

The semantics used in this work are:
\begin{enumerate}
  \item Conflict-free: $S \in cf(F)$, if there is no pair $a,b \in S$, such that
      $(a,b) \in R$.
\end{enumerate}
All of the following semantics are defined as subsets of $cf(F)$
with additional requirements:
\begin{enumerate}[resume]
  \item Admissible: $S \in adm(F)$, if $S$ defends itself.
  \item Naive: $S \in nai(F)$ if $\nexists T\in cf(F)$ with $T \supset S$.
  \item Stable: $S \in stb(F)$, if $S_F^{+} = A_F$.
  \item Preferred: $S \in prf(F)$, if $S \in adm(F)$ and $\nexists T\in adm(F)$
      with $T \supset S$.
  \item Stage: $S \in stg(F)$, if $\nexists T\in cf(F)$ with $T_F^{+} \supset
      S_F^{+}$.
  \item Semi-stable: $S \in sem(F)$, if $S \in adm(F)$ and $\nexists T\in
      adm(F)$ with $T_F^{+} \supset S_F^{+}$.
\end{enumerate}

\subsection{Framework Properties} \label{framework_props}
This project concentrated on two properties of an argumentation framework
together with a set of extensions. That means, that the concrete semantic used
is at first not considered.

An argument is rejected, if it doesn't appear in any extension:

\begin{definition}
Let $F=(A,R)$ be an argumentation framework, $\sigma$ a semantic, and $a\in A$
be an argument. $a$ is \emph{rejected} if $\nexists S\in\sigma(F): a\in S$.
\end{definition}

A framework is \emph{compact} if no argument is rejected:

\begin{definition}
Let $F=(A,R)$ be an argumentation framework, and $\sigma$ a semantic.  The
framework is \emph{compact} with respect to $\sigma$ if $\forall a\in A\exists
S\in\sigma(S):a\in S$.
\end{definition}

Secondly, pairs of arguments that never appear together in an extension
are called \emph{conflicts}. They can either be \emph{explicit}, or
\emph{implicit}:
\begin{definition}
  Let $F=(A,R)$ be an argumentation framework, $\sigma$ be an arbitrary semantic
  and $a, b\in A$ (possibly $a = b$). If $\nexists S \in \sigma(F): \{a,b\} \subseteq S$ then $a$ and
  $b$ are in \emph{conflict}. If $(a, b) \in R$ or $(b, a)\in R$, then the
  conflict is \emph{explicit}, otherwise the conflict is \emph{implicit}.
\end{definition}

A framework containing no \emph{implicit conflicts} is called \emph{analytic}:

\begin{definition}
Given an argumentation framework $F=(A,R)$ and a semantic $\sigma$, $F$ is
called \emph{analytic} if all conflicts of $F$ for $\sigma$ are explicit.
\end{definition}

Since conflicts involving an argument which is rejected are always
implicit the (number of) conflicts which do not involve a rejected
argument are of some interest and will subsequently be referred to as
\emph{Implicit Conflicts not Rejected}.

\subsection{Empirical Evaluation}
Since the tools developed for this project calculate properties of
frameworks and extensions it is obvious, that an empirical evaluation
makes sense. This evaluation serves two purposes: First, the stability
and correctness of the tools are tested. Secondly, some insightful
results might be obtained.

To test the tools a set of test frameworks is needed. The extensions
can then be computed by using on of the tools available to compute
the extensions from frameworks. In the case of this project it is
the Aspartix framework, together with the \texttt{clasp} Answer Set
Programing system.

In 2015 the first ``International Competition on Computational
Models of Argumentation''\footnote{see:
\url{http://argumentationcompetition.org/2015/}} was held. The
test set used to test the programs participating in this competition
can be used to evaluate the tools developed for this project. Furthermore,
the program \texttt{AFBenchGen2}\footnote{see \cite{afbenchgen2}} can be
 used to generate artificial Abstract Argumentation benchmarks.

\section{The Tools}
\label{tools}
In this section the tools developed for this project are described. The
first section gives detailed introduction how to compile them. Since the tools
are developed in the Haskell programing language, an  appropriate
build tool for Haskell is used.

Then the subsequent chapter documents the \texttt{analyze} tool. This tool is
used to investigate a given set of extensions together with a framework. It outputs
a list of properties and offers a number of input formats.

\texttt{statistics} is the second tool described. Given a set of input
frameworks it automatically calls a program to compute the extensions and
subsequently uses \texttt{analyze} to compute the properties of the extensions.

\subsection{Building the Tools}
Both tools are written in Haskell. While there are multiple ways to build the
tools, using \emph{Stack}\footnote{\url{https://haskellstack.org}}
is strongly suggested and documented here.

To install Stack follow the instructions on the Stack homepage.
After the installation is complete, open a terminal and navigate to either
\texttt{analyze/} or \texttt{statistics/}. Then run then following
commands, where \texttt{\{tool\}} is either \texttt{analyze} or
\texttt{statistics}:
\begin{verbatim}
> stack setup
> stack build
> stack exec {tool}
\end{verbatim}

The \texttt{stack build} command outputs the path the resulting binary
is placed in. On Linux calling \texttt{stack install} will copy the binary
to \texttt{\~{}/.local/bin}. Alternatively the programs can be run with
additional arguments (\texttt{\{args\}}) by calling
\begin{verbatim}
stack exec {tool} -- {args}
\end{verbatim}

\subsection{Analyze}

The \texttt{analyze} tool uses an argumentation framework and precomputed
extensions and returns a list of properties. Executing \texttt{analyze}
without any command line arguments results in a short description of
its arguments.

\begin{verbatim}
Usage: analyze [-t] [-c] [-n] -f FILE -e FILE

  -t         The framework is in Trivial Graph Format,
    instead of Aspartix Format.
  -c         The extensions are in ICCMA competiton format,
    instead of an output log of clasp.
  -n         Output the number of elements instead of lists
    e.g. for implicit conflicts.
  -f FILE    FILE containing the framework.
  -e FILE    FILE containing the extensions.
\end{verbatim}

Except \texttt{-f} and \texttt{-e} all arguments are optional.  The \texttt{-t}
and \texttt{-c} options control the input format. \texttt{-t} defaults to the
Aspartix format, which describes the framework using ASP syntax\footnote{For
    more information on this and the other input formats see:
\url{http://argumentationcompetition.org/2015/iccma15notes_v3.pdf}.}.
Alternatively the Trivial Graph Format can be used. The \texttt{-c} option
defaults to ``output log of \texttt{clasp}''. This means, that the input format is
expected to be the result of running \texttt{clasp}\footnote{See:
\url{https://www.cs.uni-potsdam.de/clasp/}} on the input framework. The intended
purpose of this option is to compute the extensions by using the
Aspartix\footnote{See:
\url{http://www.dbai.tuwien.ac.at/research/project/argumentation/systempage/}}
framework of ASP programs. Alternatively the format used in the ICCMA'15
competition can be used. The default options are more throughly tested then the
alternative options.

Running \texttt{analyze} on an input framework $F=(A,R)$ together with a set of
extensions $\sigma(F)$ results in a list of properties:
\begin{itemize}
  \item Arguments: The number of arguments ($|A|$).
  \item Extensions:	The number of extensions ($|\sigma(F)|$)
  \item Downwards Closed:	\texttt{True} if $\sigma(F)$ is downwards closed,
      \texttt{False} otherwise.  $\sigma(F)$ is \emph{downwards closed}, if $S
      \in \sigma(F)\Rightarrow \forall S'\subseteq S: S'\in\sigma(F)$.
  \item Tight: \texttt{True} if $\sigma(F)$ is tight, \texttt{False}
      otherwise.  $\sigma(F)$ is \emph{tight} if $\forall
      a\in\bigcup_{S\in\sigma(F)}S$ it holds, that for all $S\in\sigma(F)$ where
      $S\cup\{a\}\notin\sigma(F)$ there is an $b\in S$ such that $a$ and $b$
      never both occur in any set of $\sigma(F)$.
  \item Conflict Sensitive: \texttt{True} if $\sigma(F)$ is conflict sensitive,
      \texttt{False} otherwise.  $\sigma(F)$ is \emph{conflict sensitive} if for
      all $A, B\in\sigma(F)$ such that $A\cup B\notin\sigma(F)$ there is $a,
      b\in A\cup B$ such that $a$ and $b$ never both occur together in any set of
      $\sigma(F)$.
  \item In Signatures Of: Given a set of extensions $\mathbb{S}$ and a semantic
      $\sigma$, is there a argumentation framework $F$, such that $\mathbb{S} =
      \sigma(F)$? If such a framework exists, then $\mathbb{S}$ is said to be in
      the signature of $\sigma$. This property lists semantics in which
      signatures the given set of extensions is, as described in
      \cite{dunne2015characteristics}.
  \item Rejected Arguments: The list of rejected arguments as described in
      subsection~\ref{framework_props}.
  \item Implicit Conflicts: The list of implicit conflicts as described in
      subsection~\ref{framework_props}.
  \item Implicit Conflicts not Rejected: The list of implicit conflicts that do
      not contain rejected arguments as described in
      subsection~\ref{framework_props}.
\end{itemize}

The properties Downwards Closed, Tight, and Conflict Sensitive were
defined in \cite{dunne2015characteristics}. Note that the properties
\emph{com-closedness}, which is defined in this paper, is not
computed by \texttt{analyze}. Furthermore the program tests for
incomparability, but does not output this property to the command line.
Rejected Arguments and Implicit Conflicts were defined in
\cite{linsbichler2015hidden}.

Finally, the command line option \texttt{-n} results in \texttt{analyze}
printing the number of Rejected Arguments, Implicit Conflicts, and Implicit
Conflicts not Rejected, instead of lists.

\subsection{Statistics}

The \texttt{analyze} program calculates some properties on a given framework and
a set of its extensions. The \texttt{statistics} program takes a folder
containing frameworks, calculates their extensions and calls \texttt{analyze} on
the result. The properties are then written into a CSV file.

While \texttt{statistics} is written in Haskell and compiles to a standalone
executable, it assumes an Unix like environment and was only tested on Linux.
Similar to shell scripts it does minimal error checking and might output
somewhat convoluted error messages.

To calculate the extensions, the \emph{clasp} version of the Aspartix framework
is used.  In fact, \texttt{statistics} calls the \texttt{clingo} program, which
integrates the \texttt{gringo} grounder with the \texttt{clasp} solver. Therefore,
\texttt{clingo} version 4.4.0 must be installed.  A copy of the relevant
Aspartix programs are provided in the \texttt{APX/} subdirectory.

Executing \texttt{analyze} without any command line arguments results in a short
description of its arguments.
\begin{verbatim}
Usage: statistics -a APX_DIR -f FRAMEWORK_DIR [-tTIMELIMIT][-sSEMANTICS]
  [OUTPUTFILE]

  -a APX_DIR          Directory containing the Aspartix ASP encodings.
  -f FRAMEWORK_DIR    Directory containing the the argumentation frameworks in
    APX format.
  -d                  Delete the clingo logs after analyzing them.
  -t[TIMELIMIT]       Timelimit given to clingo. The default is 120 seconds.
    A timelimit of 0 deactivates the timelimiting.
  -p[PROPERTIES]      Properties to generate as one letter codes.
  -s[SEMANTICS]       Comma seperated list of three letter names of the
    semantics to calculate.
\end{verbatim}

The \texttt{-a} command line option specifies the directory the Aspartix ASP
programs are found in. Normally this would be the \texttt{APX\/} subdirectory.
The following programs must be present in this folder: \texttt{adm.dl},
\texttt{prefex\_gringo.lp}, \texttt{semi\_stable\_gringo.lp},
\texttt{stable.dl}, \texttt{stage\_gringo.lp}.  The \texttt{-f} command line
option specifies the directory containing the frameworks in Aspartix format.
This directory will be scanned recursively for files ending
in \texttt{.apx}. The program will then create a new
dictionary, \texttt{out/}, where the \texttt{clingo} logs will be created.
Since the logs are often quite big the \texttt{-d} option will instruct
\texttt{statistics} to delete the logs right after they have been used.
To restrict the time that \texttt{clingo} is allowed to use per call, the
\texttt{-t} option can be used. The default is 120 seconds. Time-limiting
\texttt{clingo} can be disabled by \texttt{-t0}.
If \texttt{clingo} times out for all requested semantics, the affected
framework will be skipped entirely.

The \texttt{p}

Finally, the optional \texttt{-s} option allows the user to restrict the
semantics used. The list can contain the following three letter names:
\texttt{adm}, \texttt{stb}, \texttt{prf}, \texttt{stg}, \texttt{sem}. Note that
the order in the output file will always be as given in this list, even when the
names given to \texttt{-s} are in a different order. If a filename is given to
\texttt{statistics} as \texttt{OUTPUTFIILE}, this name is used for the CSV file.
Otherwise it will be called \texttt{out.csv}.

The \texttt{-p} option allows the user to overwrite the properties that
get written into the output file. To keep the command line short one
letter codes are used.
By default the following properties are used: The number
of Extensions, the number of Rejected Arguments, the number of Implicit
Conflicts, and the number of Implicit Conflicts not Rejected.
The one letter codes are the following:
\begin{itemize}
	\item \texttt{'a' = "Arguments"}
	\item \texttt{'e' = "Extensions"}
	\item \texttt{'d' = "Downwards Closed"}
	\item \texttt{'t' = "Tight"}
	\item \texttt{'c' = "Conflict Sensitive"}
	\item \texttt{'s' = "In Signatures Of"}
	\item \texttt{'r' = "Rejected Arguments"}
	\item \texttt{'i' = "Implicit Conflicts"}
	\item \texttt{'j' = "Implicit Conflicts not Rejected"}
\end{itemize}
Accordingly the default of \texttt{-p} is \texttt{erij}.

The output file generated by \texttt{statistics} is a CSV file. The columns are
separated by the comma character (\texttt{,}). The file contains one row for
every framework in the input directory and contains its name in the first
column. The second column contains the number of arguments in the framework.
Then the file contains columns for every property requested by the \texttt{-p}
option. This is repeated for every semantic. The very first
line of the CSV file is a header and can be ignored. If a \texttt{clingo} call
times out, the affected values in the output file will replaced by the string
\texttt{NaN}. In case of an \texttt{analyze} crash \texttt{statistics} will
replace the values with \texttt{Err}.

\section{Evaluation}
\label{evaluation}
This section describes the empirical evaluation done for this project.
The first section outlines how the set of benchmarks was obtained and selected.

\subsection{Generating the Benchmarks}
\label{gen_bench}
The frameworks used for evaluation come from two sources. On one hand,
the frameworks used in the first ``International Competition on Computational
Models of Argumentation'' (ICCMA'15) were used. On the other hand,
the program \texttt{AFBenchGen2} was used to generate artificial
abstract argumentation frameworks.

The ICCMA'15 dataset is divided into nine subsets, constructed from
three different graph types. According to the competition
homepage\footnote{\url{http://argumentationcompetition.org/2015/results.html}}
those are:
\begin{enumerate}
  \item Graphs with many nodes and very large grounded instances\footnote{
  Grounded instances are the biggest sets in the complete extensions. The complete
  extensions were not defined in section~\ref{aadef}, because they do not appear
  in \cite{linsbichler2015hidden}. An extension $S\in cf(F)$ is \emph{complete}, iff
  the set of arguments defended by $S$ is a subset of $S$.}.
  \item Graphs which feature many complete/preferred/stable extensions.
  \item Graphs which feature a rich structure of strongly connected components.
\end{enumerate}
For the first and third type of graphs the problems collected into groups
containing problems of three diffident sizes: small, medium, and large. For the
second type, only small and medium sized problems are available. Note that for
the competition only complete, preferred, grounded, and stable semantics were
used. First experiments with some frameworks from the small instances of the
second type showed that for stage semantics output logs of unsuitable size were
generated ($\geq$ 65GB in minutes).

AFBenchGen2\footnote{Available at:
\url{https://sourceforge.net/projects/afbenchgen/}} is a tool to generate
benchmark problems for abstract argumentation solvers\cite{afbenchgen2}. The
program supports the creation of argumentation frameworks with an arbitrary
number of arguments $n$. Three modes can then be selected to generate the
attack relation.

\emph{Erdös-Rényi} graphs are generated by randomly deciding if an attack
between two nodes is added. The probability to select an attack is an additional
parameter given to the program (between 0 and 1).

\emph{Watts-Strogatz} graphs are generated by first creating a ring of $n$
arguments which are each connected to their $k$ nearest neighbors. $k$ is called
the base degree and must satisfy $n \gg k \gg log(n) \gg 1$. Then the tool
considers each argument and rewires each of its edges towards the not yet
considered nodes. The probability that an argument is chosen is the parameter
$\beta$ (again between 0 and 1).

\emph{Barabasi-Albert} graphs are generated by iteratively adding new nodes and
connecting them to the previous nodes by preferring already well connected
components.

Because Watts-Strogatz and Barabasi-Albert graphs would result in cycle free
graphs, the generator takes as additional argument the probability (between 0
and 1) that an argument is in at least one cycle.

\todo[inline]{this is not done yet}

\section{Conclusion}
\label{conclusion}
\todo[inline]{write}

\printbibliography
\end{document}
